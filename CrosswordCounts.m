(* ::Package:: *)

(* ::Input:: *)
(*BeginPackage["CrosswordCounts`"];*)
(**)
(*count::usage="count[m,n,w,t] returns the number of symmetric, connected m \[Times] n grids with words of length \[GreaterEqual] w (called \"valid\" grids).*)
(*	If t \[Equal] 1 the grids must be tight (white squares touch each border wall) and if t \[Equal] 0 the grids can be loose.*)
(*	count[m,n,w,t] \[Equal] count[n,m,w,t] though it is more efficient to put the larger of m and n as the first argument.*)
(*count[n,w,t] may be used for the square case (number of valid n \[Times] n grids).\[IndentingNewLine]Options:*)
(*	compMode:  Computation mode.*)
(*		\[LessEqual] 0 to output single count (0 = silent, -1 = verbose),*)
(*		> 0 to output list of counts (1 = silent, 2 = print results as computed, 3 = verbose)*)
(*		Default:  0*)
(*	readIndex:  1 to start from scratch, \[GreaterEqual] 2 to read corresponding save file*)
(*		Default:  1*)
(*	saveQ:  Whether to save intermediate results*)
(*		Default:  False*)
(*	saveRoot:  Root of save file name for reading (readIndex \[GreaterEqual] 2) and  writing (saveQ \[Equal] True)*)
(*		Default:  \"cws\"*)
(*	saveDirectory:  Directory for save files*)
(*		Default:  Automatic (= directory of notebook calling the package)";*)
(**)
(*countMat::usage="countMat[mMax,nMax,w,t] returns the matrix of count[m,n,w,t] for 1 \[LessEqual] m \[LessEqual] mMax and 1 \[LessEqual] n \[LessEqual] nMax.*)
(*countMat[nMax,w,t] may be used for the square case (all valid grids up to nMax \[Times] nMax).";*)
(**)
(*convertToLoose::usage="convertToLoose[tmat] converts a matrix of counts for the tight case (t \[Equal] 1) to the loose case (t \[Equal] 0). Thus if countMat[mMax,nMax,w,1] has been computed, there is no need to also compute countMat[mMax,nMax,w,0]";*)
(**)
(*nValidGrids::usage="nValidGrids[m,n,w,t] returns the number of symmetric, connected m \[Times] n grids with words of length \[GreaterEqual] w (called \"valid\" grids).*)
(*	If t \[Equal] 1 the grids must be tight (white squares touch each border wall) and if t \[Equal] 0 the grids can be loose.*)
(*	This is the same as count[m,n,w,t], but computed by explicitly listing all such grids (via allValidGrids).*)
(*nValidGrids[n,w,t] may be used for the square case (number of valid n \[Times] n grids).";*)
(**)
(*nValidGridClasses::usage="nValidGridClasses[m,n,w,t] returns the number of symmetric, connected \"grid classes\" with words of length \[GreaterEqual] w. A grid class contains the 1, 2, or 4 grids that are images of one another under all symmetries of the square (i.e., not just the 180\[Degree] rotational symmetry that is required of all valid grids).*)
(*nValidGridClasses[n,w,t] may be used for the square case (number of valid n \[Times] n grid classes).";*)
(**)
(*sizesValidGridClasses::usage="sizesValidGridClasses[m,n,w,t] returns a list of the number of valid grid classes for each of the 5 possible symmetry types: All, 90\[Degree] Rotations, About both diagonals, About the horizontal and vertical centerlines, and None (i.e., 180\[Degree] rotational symmetry only).*)
(*sizesValidGridClasses[n,w,t] may be used for the square case (valid n \[Times] n grid classes).";*)
(**)
(*allValidGrids::usage="allValidGrids[m,n,w,t] returns the list of all symmetric, connected m \[Times] n grids with words of length \[GreaterEqual] w (called \"valid\" grids).*)
(*	If t \[Equal] 1 the grids must be tight (white squares touch each border wall) and if t \[Equal] 0 the grids can be loose.*)
(*	This is achieved by efficiently generating all m \[Times] n symmetric grids with words of length \[GreaterEqual] w and then downselecting to the connected grids. In the t \[Equal] 1 case these are further downselected to tight grids.*)
(*allValidGrids[n,w,t] may be used for the square case (valid n \[Times] n grids).";*)
(**)
(*allValidGridClasses::usage="allValidGridClasses[m,n,w,t] returns a list of lists of representative grids from all valid grid classes for each of the 5 possible symmetry types: All, 90\[Degree] Rotations, About both diagonals, About the horizontal and vertical centerlines, and None (i.e., 180\[Degree] rotational symmetry only).*)
(*allValidGridClasses[n,w,t] may be used for the square case (valid n \[Times] n grid classes).";*)
(**)
(*nMaximalGrids::usage="nMaximalGrids[m,n,w] returns the number of \"maximal\" m \[Times] n grids with words of length \[GreaterEqual] w. This is the length of allMaximalGrids[m,n,w].*)
(*nMaximalGrids[n,w] may be used for the square case (number of maximal n \[Times] n grids).";*)
(**)
(*nMaximalGridClasses::usage="nMaximalGridClasses[m,n,w] returns the number of maximal \"grid classes\" with words of length \[GreaterEqual] w. A grid class contains the 1, 2, or 4 grids that are images of one another under all symmetries of the square (i.e., not just the 180\[Degree] rotational symmetry that is required of all maximal grids).*)
(*nMaximalGridClasses[n,w] may be used for the square case (number of maximal n \[Times] n grid classes).";*)
(**)
(*sizesMaximalGridClasses::usage="sizesMaximalGridClasses[m,n,w] returns a list of the number of maximal grid classes for each of the 5 possible symmetry types: All, 90\[Degree] Rotations, About both diagonals, About the horizontal and vertical centerlines, and None (i.e., 180\[Degree] rotational symmetry only).*)
(*sizesMaximalGridClasses[n,w] may be used for the square case (maximal n \[Times] n grid classes).";*)
(**)
(*allMaximalGrids::usage="allMaximalGrids[m,n,w] returns the list of all \"maximal\" m \[Times] n grids with words of length \[GreaterEqual] w. These are defined to be the subset of allValidGrids[m,n,w] which are maximal with respect to a certain partial order \[PrecedesSlantEqual]. For any two grids G and H, let H \[PrecedesSlantEqual] G if G contains all H's white squares but doesn't merge any of its words. (Merging horizontal words occurs when two white squares in the same row are in different across-words in H but the same word in G, and similarly for down-words.) All maximal grids are tight, so there is no t argument in any of the \"Maximal\" functions.*)
(*allMaximalGrids[n,w] may be used for the square case (maximal n \[Times] n grids).";*)
(**)
(*allMaximalGridClasses::usage="allMaximalGridClasses[m,n,w] returns a list of lists of representative grids from all maximal grid classes for each of the 5 possible symmetry types: All, 90\[Degree] Rotations, About both diagonals, About the horizontal and vertical centerlines, and None (i.e., 180\[Degree] rotational symmetry only).*)
(*allMaximalGridClasses[n,w] may be used for the square case (maximal n \[Times] n grid classes).";*)
(**)
(*plotGrids::usage="plotGrids[grids] plots either a single grid, a list of grids, or a list of lists of grids (such as the output of allValidGridClasses or allMaximalGridClasses). The grids are color-coded by symmetry type.*)
(*plotGrids[grids,squareSize] plots the grids with a squareSize (default = 30).*)
(*plotGrids[grids,squareSize,width] when width > 0, this is the number of grids per row of the plot (default = 0 means width selected automatically).";*)
(**)
(*tightSquareCount::usage="tightSquareCount[n,w] returns the value of count[n,n,w,1] if known (either pre-computed or given by a simple formula).  It returns -1 if the answer is unknown.";*)
(**)
(*countMat15::usage="countMat15[3,t] returns the pre-computed value of countMat[15,15,3,1] for the tight case (t \[Equal] 1) or the value of countMat[15,15,3,0] obtained from this (via convertToLoose) for the loose case (t \[Equal] 0).";*)
(**)
(*checkAllQ::usage="checkAllQ[] performs a number of checks to verify the consistency of the explicit grid enumeration routines and check the agreement between the efficient count routine and the explicit grid enumeration routine allValidGrids.*)
(*checkAllQ[False] suppresses the reports from the individual checks.";*)
(**)
(*checkCountQ::usage="checkCountQ[mMax,nMax,w] checks that (efficient) count[m,n,w,t] gives the same result as the (slow-but-explicit) nValidGrids[m,n,w,t] for all 1 \[LessEqual] m \[LessEqual] mMax, 1 \[LessEqual] n \[LessEqual] nMax, and t = 0 or 1.  It also tests that count[m,n,w,t] \[Equal] count[n,m,w,t] and that count[m,n,w,0] \[Equal] convertToLoose[count[m,n,w,1]].*)
(*checkCountQ[nMax,w] may be used for the square case (all valid grids up to nMax \[Times] nMax).*)
(*checkCountQ[mMax,nMax,w,False] or checkCountQ[nMax,w,False] may be used to suppress the reports from individual checks.";*)
(**)
(*checkInternalQ::usage="checkInternalQ[bMax] checks the consistency of allSymWrdGrids with allWrdGrids and with allSymGrids for all m \[Times] n grids with m and n at least w and m*n \[LessEqual] bMax, as well as the consistency of allWrdGrids and allSymGrids with allGrids for all grids with m*n \[LessEqual] Ceiling[bMax/2]. All these routines are internal.*)
(*checkInternalQ[bMax,False] suppresses the reports from the individual checks.";*)
(**)
(*Begin["`Private`"];*)
(**)
(*(**** Public ****)*)
(**)
(*(*** Count routines ***)*)
(**)
(*(* count[m,n,w,t] is the number of m x n symmetric, wordy, connected grids with words of length at least w*)
(*If t is 1 the grids must be tight (white squares touch each border wall) and if t is 0 the grids can be loose *)*)
(*Protect[compMode,readIndex,saveQ,saveRoot,saveDirectory];*)
(*Options[count]={*)
(*compMode->0, (* \[LessEqual] 0 to output single count (0 = silent, -1 = verbose),*)
(*positive to output list of counts (1 = silent, 2 = print results as computed, 3 = verbose) *)*)
(*saveQ->False, (* Whether to save intermediate results *)*)
(*readIndex->1, (* 1 to start from scratch, > 1 to read corresponding save file *) *)
(*saveRoot->"cws", (* Root string for file name *)*)
(*saveDirectory->Automatic (* Directory for save and restart files *)*)
(*};*)
(*count[n_Integer,w_Integer,t_Integer,opts:OptionsPattern[]]:=count[n,n,w,t,opts]*)
(*count[m_Integer,n_Integer,w_Integer,t_Integer,OptionsPattern[]]:=Module[{mode=OptionValue[compMode],svQ=OptionValue[saveQ],itMin=OptionValue[readIndex],svRoot=OptionValue[saveRoot],svDirectory=OptionValue[saveDirectory],tightQ=(t!=0),svDir="",svPrefix="",svSuffix="",verboseQ,tStamp=0.0,file,itMax=Max[1,Floor[m/2]],a,totalList,total},*)
(*verboseQ=mode<0||mode>2;*)
(*If[svQ||itMin!=1,*)
(*If[svDirectory===Automatic,svDir=NotebookDirectory[],*)
(*If[Not@DirectoryQ[svDir=NotebookDirectory[]<>"\\"<>svDirectory],svDir=svDirectory]];*)
(*SetDirectory@svDir;*)
(*svPrefix=If[svRoot===Automatic,"cws",svRoot]<>"_"<>If[tightQ,"T","L"]<>ToString[w]<>"_"<>ToString[n]<>"_";*)
(*svSuffix=".wl";*)
(*];*)
(*If[verboseQ,tStamp=AbsoluteTime[]];*)
(*If[itMin==1,*)
(*a=init[n,w,tightQ];*)
(*If[verboseQ,tStamp=printStatus[tStamp,a,1,itMax,True]],*)
(*file=svPrefix<>ToString[itMin]<>svSuffix;*)
(*If[FileExistsQ[file],*)
(*a=Get[file];*)
(*If[verboseQ,tStamp=printStatus[tStamp,a,itMin,itMax,False]];*)
(*If[Not[Head[a]===Association],Print["Badly formed restart file"];Abort[]],*)
(*Print["File ",file," not found"];Abort[];*)
(*];*)
(*];*)
(*If[mode>0,*)
(*totalList={};*)
(*If[itMin==1,*)
(*total=If[w==1,If[tightQ,1,symConRowTotal[a]],If[tightQ,0,1]];*)
(*AppendTo[totalList,total];*)
(*tStamp=printIntermediate[tStamp,total,1,n,w,tightQ,mode]*)
(*];*)
(*If[2itMin<=m,*)
(*total=finishEven[a,w,tightQ];*)
(*AppendTo[totalList,total];*)
(*tStamp=printIntermediate[tStamp,total,2itMin,n,w,tightQ,mode];*)
(*];*)
(*If[2itMin+1<=m,*)
(*total=finishOdd[a,w,tightQ];*)
(*AppendTo[totalList,total];*)
(*tStamp=printIntermediate[tStamp,total,2itMin+1,n,w,tightQ,mode];*)
(*];*)
(*];*)
(*Do[*)
(*a=iter[a,w];*)
(*If[svQ,file=svPrefix<>ToString[it]<>svSuffix;Put[a,file]];*)
(*If[verboseQ,tStamp=printStatus[tStamp,a,it,itMax,True]];*)
(*If[mode>0,*)
(*total=finishEven[a,w,tightQ];*)
(*AppendTo[totalList,total];*)
(*tStamp=printIntermediate[tStamp,total,2it,n,w,tightQ,mode];*)
(*If[2it+1<=m,*)
(*total=finishOdd[a,w,tightQ];*)
(*AppendTo[totalList,total];*)
(*tStamp=printIntermediate[tStamp,total,2it+1,n,w,tightQ,mode];*)
(*];*)
(*],{it,itMin+1,itMax}];*)
(*If[mode>0,*)
(*totalList,*)
(*total=If[m==1,*)
(*If[w==1,symConRowTotal[a],If[tightQ,0,1]],*)
(*If[EvenQ[m],finishEven[a,w,tightQ],finishOdd[a,w,tightQ]]*)
(*];*)
(*If[verboseQ,Print["\[CapitalDelta]t = ",AbsoluteTime[]-tStamp,": Final step"]];*)
(*total*)
(*]*)
(*]/;(m>=1&&n>=1&&w>= 1&&0<=t<=1)*)
(**)
(*(** Other count routines **)*)
(**)
(*(* Returns the matrix of counts for 1 \[LessEqual] m \[LessEqual] mMax and 1 \[LessEqual] n \[LessEqual] nMax *)*)
(*countMat[mMax_Integer,nMax_Integer,w_Integer,t_Integer]:=If[nMax>mMax,Transpose@countMatRaw[nMax,mMax,w,t],countMatRaw[mMax,nMax,w,t]]/;(mMax>=1&&nMax>=1&&w>= 1&&0<=t<=1)*)
(*countMat[nMax_Integer,w_Integer,t_Integer]:=countMatRaw[nMax,nMax,w,t](* Shortcut for square case *)*)
(**)
(*(* Converts a matrix of counts for the tight case (t \[Equal] 1) to the loose case (t \[Equal] 0) *)*)
(*convertToLoose[tmat_List]:=Table[1+totWhite@tmat[[Mod[i,2,1];;i;;2,Mod[j,2,1];;j;;2]],{i,Length[tmat]},{j,Length[tmat[[1]]]}]*)
(**)
(*(*** Grid enumeration routines ***)*)
(**)
(*(* Number of valid m x n grids with words of length at least w *)*)
(*nValidGrids[m_Integer,n_Integer,w_Integer,t_Integer]:=Length@allValidGrids[m,n,w,t]/;(m>=1&&n>=1&&w>= 1&&0<=t<=1)*)
(*nValidGrids[n_Integer,w_Integer,t_Integer]:=nValidGrids[n,n,w,t](* Shortcut for square case *)*)
(**)
(*nValidGridClasses[m_Integer,n_Integer,w_Integer,t_Integer]:=Total@sizesValidGridClasses[m,n,w,t]/;(m>=1&&n>=1&&w>= 1&&0<=t<=1)*)
(*nValidGridClasses[n_Integer,w_Integer,t_Integer]:=nValidGridClasses[n,n,w,t](* Shortcut for square case *)*)
(**)
(*sizesValidGridClasses[m_Integer,n_Integer,w_Integer,t_Integer]:=Length/@allValidGridClasses[m,n,w,t]/;(m>=1&&n>=1&&w>= 1&&0<=t<=1)*)
(*sizesValidGridClasses[n_Integer,w_Integer,t_Integer]:=sizesValidGridClasses[n,n,w,t](* Shortcut for square case *)*)
(**)
(*(* Number of maximal m x n grids with words of length at least w *)*)
(*nMaximalGrids[m_Integer,n_Integer,w_Integer]:=Length@allMaximalGrids[m,n,w]/;(m>=1&&n>=1&&w>= 1)*)
(*nMaximalGrids[n_Integer,w_Integer]:=nMaximalGrids[n,n,w] (* Shortcut for square case *)*)
(**)
(*nMaximalGridClasses[m_Integer,n_Integer,w_Integer]:=Total@sizesMaximalGridClasses[m,n,w]/;(m>=1&&n>=1&&w>= 1)*)
(*nMaximalGridClasses[n_Integer,w_Integer]:=nMaximalGridClasses[n,n,w](* Shortcut for square case *)*)
(**)
(*sizesMaximalGridClasses[m_Integer,n_Integer,w_Integer]:=Length/@allMaximalGridClasses[m,n,w]/;(m>=1&&n>=1&&w>= 1)*)
(*sizesMaximalGridClasses[n_Integer,w_Integer]:=sizesMaximalGridClasses[n,n,w](* Shortcut for square case *)*)
(**)
(*Clear[allValidGrids,allValidGridClasses,allMaximalGrids,allMaximalGridClasses]; (* Clear stored values *)*)
(**)
(*(* Generate and store all valid m x n grids with words of length at least w *)*)
(*allValidGrids[m_Integer,n_Integer,w_Integer,0]:=(allValidGrids[m,n,w,0]=Select[allSymWrdGrids[m,n,w],gridConQ])/;(m>=1&&n>=1&&w>= 1)*)
(*allValidGrids[m_Integer,n_Integer,w_Integer,1]:=(allValidGrids[m,n,w,1]=Select[allValidGrids[m,n,w,0],gridTgtQ])/;(m>=1&&n>=1&&w>= 1)*)
(*allValidGrids[n_Integer,w_Integer,t_Integer]:=allValidGrids[n,n,w,t] (* Shortcut for square grids *)*)
(**)
(*(* Generate and store partition of valid grids by symmetry class *)*)
(*allValidGridClasses[m_Integer,n_Integer,w_Integer,t_Integer]:=(allValidGridClasses[m,n,w,t]=symClasses@allValidGrids[m,n,w,t]) /;(m>=1&&n>=1&&w>= 1&&0<=t<=1)*)
(*allValidGridClasses[n_Integer,w_Integer,t_Integer]:=allValidGridClasses[n,n,w,t](* Shortcut for square grids *)*)
(**)
(*(* Generate and store all maximal m x n grids with words of length at least w  *)*)
(*allMaximalGrids[m_Integer,n_Integer,w_Integer]:=(allMaximalGrids[m,n,w]=cullToMax@allValidGrids[m,n,w,1])/;(m>=1&&n>=1&&w>= 1)*)
(*allMaximalGrids[n_Integer,w_Integer]:=allMaximalGrids[n,n,w](* Shortcut for square grids *)*)
(**)
(*allMaximalGridClasses[m_Integer,n_Integer,w_Integer]:=(allMaximalGridClasses[m,n,w]=symClasses@allMaximalGrids[m,n,w])/;(m>=1&&n>=1&&w>= 1)*)
(*allMaximalGridClasses[n_Integer,w_Integer]:=allMaximalGridClasses[n,n,w](* Shortcut for square grids *)*)
(**)
(*(*** Plotting routines ***)*)
(**)
(*(* Plots a grid, an array of grids, or a partition of grids by symmetry class *)*)
(*plotGrids[grids_List,squareSize_Integer:30,width_Integer:0]:=With[{d=Depth[grids]},*)
(*If[d==3,plotGrid[grids,squareSize],If[Length[grids]==1,plotGrid[grids[[1]],squareSize],*)
(*plotGridsSub[If[d>4,Flatten[grids,1],grids],squareSize,width]]]]*)
(**)
(*(*** Stored results ***)*)
(**)
(*(* Pre-computed counts of valid n x n grids for the tight case (t \[Equal] 1).  Returns -1 if count unknown *)*)
(*tightSquareCount[n_Integer,w_Integer]:=If[w>n,0,If[w<=7&&n-w+1<=Length@tightSquareCountList[w],tightSquareCountList[w][[n-w+1]],squareCountFormula[n,w,1]]]/;(n>=1&&w>=1)*)
(**)
(*(* Counts of all m x n grids up to m = n = 15 for the tight, w = 3 case *)*)
(*countMat15[3,1]=*)
(*{{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},*)
(*{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},*)
(*{0,0,1,1,1,1,1,1,1,1,1,1,1,1,1},*)
(*{0,0,1,3,5,7,7,13,15,33,37,75,89,175,211},*)
(*{0,0,1,5,12,22,34,64,115,259,468,980,1742,3606,6519},*)
(*{0,0,1,7,22,48,86,178,367,973,2132,5456,11520,28508,60985},*)
(*{0,0,1,7,34,86,312,626,1754,3990,12931,30741,100126,234362,749439},*)
(*{0,0,1,13,64,178,626,2190,6746,21972,66411,234143,738990,2613144,8061187},*)
(*{0,0,1,15,115,367,1754,6746,31187,108089,472654,1599558,7463594,25710394,119869867},*)
(*{0,0,1,33,259,973,3990,21972,108089,586731,2542446,13038460,57394116,298289312,1325038289},*)
(*{0,0,1,37,468,2132,12931,66411,472654,2542446,17438702,85912738,571540158,2794999844,18851755888},*)
(*{0,0,1,75,980,5456,30741,234143,1599558,13038460,85912738,654057540,4163555192,30763310300,196071884168},*)
(*{0,0,1,89,1742,11520,100126,738990,7463594,57394116,571540158,4163555192,40575832476,287957992192,2772709489316},*)
(*{0,0,1,175,3606,28508,234362,2613144,25710394,298289312,2794999844,30763310300,287957992192,3115321983734,28813678808484},*)
(*{0,0,1,211,6519,60985,749439,8061187,119869867,1325038289,18851755888,196071884168,2772709489316,28813678808484,404139015237875}};*)
(**)
(*(* Counts of all m x n grids up to m = n = 15 for the loose, w = 3 case *)*)
(*countMat15[3,0]:=convertToLoose@countMat15[3,1];*)
(**)
(*(* Tight and loose answers for m = n = 15 and w = 3:  404139015237875 and 409764131469788 *)*)
(**)
(*(*** Checks ***)*)
(**)
(*(* Performs all consistency checks *)*)
(*checkAllQ[verboseQ:(_?BooleanQ):True]:=checkInternalQ[20,verboseQ]&&AllTrue[Range[7],checkCountQ[#+4,#,verboseQ]&]*)
(**)
(*(* Checks that count computation agrees with explicit enumeration of grids *)*)
(*checkCountQ[mMax_Integer,nMax_Integer,w_Integer,verboseQ:(_?BooleanQ):True]:=Module[{mat0=countMatRaw[mMax,nMax,w,0],mat1=countMatRaw[mMax,nMax,w,1],r=Min[mMax,nMax],results},*)
(*results={*)
(*mat0[[1;;r,1;;r]]==Transpose[mat0[[1;;r,1;;r]]],*)
(*mat1[[1;;r,1;;r]]==Transpose[mat1[[1;;r,1;;r]]],*)
(*mat0==convertToLoose@mat1,*)
(*mat0==Table[nValidGrids[m,n,w,0],{m,mMax},{n,nMax}],*)
(*mat1==Table[nValidGrids[m,n,w,1],{m,mMax},{n,nMax}]};*)
(*If[verboseQ,Print[*)
(*"countMat[",r,",",r,",",w,",0] symmetric? ",results[[1]],*)
(*"\ncountMat[",r,",",r,",",w,",1] symmetric? ",results[[2]],*)
(*"\ncountMat[",mMax,",",nMax,",",w,",0] \[Equal] convertToLoose[countMat[",mMax,",",nMax,",",w,",1]]? ",results[[3]],*)
(*"\ncount[m,n,",w,",0] \[Equal] nValidGrids[m,n,",w,",0] for 1 \[LessEqual] m \[LessEqual] ",mMax," and 1 \[LessEqual] n \[LessEqual] ",nMax,"? ",results[[4]],*)
(*"\ncount[m,n,",w,",1] \[Equal] nValidGrids[m,n,",w,",1] for 1 \[LessEqual] m \[LessEqual] ",mMax," and 1 \[LessEqual] n \[LessEqual] ",nMax,"? ",results[[5]]*)
(*]];*)
(*And@@results*)
(*]/;(mMax>=1&&nMax>=1&&w>= 1)*)
(*checkCountQ[nMax_Integer,w_Integer,verboseQ:(_?BooleanQ):True]:=checkCountQ[nMax,nMax,w,verboseQ]/;nMax<=Min[1.8w+5.7,w+9](* Square case restricted to reasonable values *)*)
(**)
(*(* Check that symmetric wordy generation routine is consistent for all grids with up to bMax squares and that lower-level routines are consistent up to half that size *)*)
(*checkInternalQ[bMax_Integer,verboseQ:(_?BooleanQ):True]:=With[{hbMax=Ceiling[bMax/2]},allSymGridChecksQ[hbMax,verboseQ]&&allWrdGridChecksQ[hbMax,2,verboseQ]&&allSymWrdGridChecksQ[bMax,2,verboseQ]]/;1<=bMax<=50*)
(**)
(*(**** Private ****)*)
(**)
(*(*** Stored results ***)*)
(**)
(*(* Lists of pre-computed results *)*)
(*tightSquareCountList[1]={1,1,11,47,1411,21411,2123851,124511195,42999348087,9581445219371,11829924769055787};*)
(*tightSquareCountList[2]={1,3,10,59,484,7250,181575,6826137,446562953,43131669850,7112223095914};*)
(*tightSquareCountList[3]={1,3,12,48,312,2190,31187,586731,17438702,654057540,40575832476,3115321983734,404139015237875};*)
(*tightSquareCountList[4]={1,3,12,50,208,1336,9119,113415,1993875,37724992,1290193576,45949047420};*)
(*tightSquareCountList[5]={1,3,12,50,210,880,5971,38421,487427,7583483,126501143};*)
(*tightSquareCountList[6]={1,3,12,50,210,882,3694,25455,165436,2079601};*)
(*tightSquareCountList[7]={1,3,12,50,210,882,3696,15442,109248};*)
(**)
(*(* Formula for the number of (tight) grids in simple cases *)*)
(*squareCountFormula[n_Integer,w_Integer,1]:=If[2w>n,Binomial[2(n-w),n-w](n-w+2)/2,If[2w==n,squareCountFormula[n+1,w+1,1]-2,-1]]/;(n>=1&&w>=1)*)
(**)
(*(* Formula for the number of loose grids in simple cases *)*)
(*squareCountFormula[n_Integer,w_Integer,0]:=If[w>n,1,With[{heads={2,4,16,68,298,1294,5564,23716,100378,422438}},*)
(*If[n-w+1>Length[heads],-1,If[2w>n,heads[[n-w+1]],If[2w==n,heads[[n-w+1]]-2,-1]]]]]/;(n>=1&&w>=1)*)
(**)
(*(* Numbers of each maximal grids of each symmetry type for w = 3, n = 1 to 10 *)*)
(**)
(*maxGridClassSizes[3]={{0,0,0,0,0},{0,0,0,0,0},{1,0,0,0,0},{1,0,0,0,0},{1,0,0,0,0},{1,0,0,0,0},{4,0,0,3,0},{1,3,4,0,10},{7,7,14,9,66},{1,14,39,0,478}};*)
(**)
(*(*** Computation routines ***)*)
(**)
(*(* Returns the matrix of counts for 1 \[LessEqual] m \[LessEqual] mMax and 1 \[LessEqual] n \[LessEqual] nMax without ensuring that mMax \[GreaterEqual] nMax for efficiency *)*)
(*countMatRaw[mMax_Integer,nMax_Integer,w_Integer,t_Integer]:=Transpose@Table[count[mMax,n,w,t,compMode->1],{n,nMax}]/;(mMax>=1&&nMax>=1&&w>= 1&&0<=t<=1)*)
(**)
(*(* Returns all wordy initial rows of length n.  Omits the zero row in tight case *)*)
(*initialRows[n_Integer,w_Integer,tightQ:(_?BooleanQ),reducedQ:(_?BooleanQ)]:=Select[Drop[allWrdRows[n,w],If[tightQ,1,0]],(Not[reducedQ]||OrderedQ[{#,Reverse[#]}])&]*)
(**)
(*(* Computes and stores all middle rows (symmetric rows of length n); if ttQ \[Equal] False, then require middle row to touch wall *)*)
(*Clear[middleRows];*)
(*middleRows[n_Integer,w_Integer,True]:=middleRows[n,w,True]=allSymWrdRows[n,w]*)
(*middleRows[n_Integer,w_Integer,False]:=middleRows[n,w,False]=Select[middleRows[n,w,True],#[[1]]==1&]*)
(**)
(*(* Computes all possible next rows *)*)
(*nextRows[row_List,w_Integer]:=If[w==1,allRows[Length[row]],allWrdNextRows[row,w]]*)
(**)
(*(* Relabel non-zero elements of row to the cluster numbers given by clusts. Assumes length of clusts \[Equal] number of words in row *)*)
(*expandClusters[row_List,clusts_List]:=Module[{offQ=True,k=0},*)
(*Table[If[row[[i]]>0,If[offQ,k++;offQ=False];clusts[[k]],offQ=True;0],{i,Length[row]}]*)
(*]*)
(**)
(*(* Returns {goodQ, newClusts} where goodQ \[Equal] False when a cluster is stranded, and newClusts are the cluster labels for newRow  *)*)
(*labelNext[clusLabRow_List,uclusts_List,newRow_List]:=Module[{map,kmax,kr,a=<||>,j=0,v},*)
(*map=Union[Select[#,Positive]]&/@Select[SplitBy[Transpose[{clusLabRow,newRow}],Last[#]>0&],#[[1,2]]>0&][[All,All,1]];*)
(*If[Union[Flatten[map]]===uclusts,*)
(*kmax=Max[Append[Flatten[map],0]];*)
(*Do[kr=Min[Flatten@Select[map,MemberQ[#,k]&]];*)
(*If[kr<k,map=Union/@(map/.k->kr)],{k,kmax,2,-1}*)
(*];*)
(*{True,Table[If[Length[map[[k]]]==0,++j,v=map[[k,1]];If[KeyExistsQ[a,v],a[v],a[v]=++j]],{k,Length[map]}]},*)
(*{False,{}}*)
(*]*)
(*]*)
(**)
(*(* Converts a 0-1 row into a state *)*)
(*initialRowToState[row_List,tightQ:(_?BooleanQ)]:=Join[{row,Range@Length@Select[Split[row],#[[1]]==1&]},If[tightQ,{row[[1]]==1||row[[-1]]==1},{}]]*)
(**)
(*(* Initialization *)*)
(*init[n_Integer,w_Integer,tightQ:(_?BooleanQ)]:=<|(initialRowToState[#,tightQ]->If[#==Reverse[#],1,2])&/@initialRows[n,w,tightQ,True]|>*)
(**)
(*(* Iterate the computation by one row *)*)
(*iter[a_Association,w_Integer]:=Module[{b=<||>,cnt,bkeys,cbkey},*)
(*Do[*)
(*cnt=a[key];*)
(*bkeys=nextStates[key,w];*)
(*Do[*)
(*cbkey=canon[bkey];*)
(*If[KeyExistsQ[b,cbkey],b[cbkey]+=cnt,b[cbkey]=cnt]*)
(*,{bkey,bkeys}]*)
(*,{key,Keys[a]}];*)
(*b*)
(*]*)
(**)
(*(* Print the status of a computation *)*)
(*printStatus[tStamp_Real,a_Association,it_Integer,tot_Integer,computedQ:(_?BooleanQ)]:=With[{tStampNext=AbsoluteTime[]},Print["\[CapitalDelta]t = ",tStampNext-tStamp,": Row ",it,"/",tot,If[computedQ," complete - ", " read - "], Length[a]," states, partial count = ",Total[a]];tStampNext]*)
(**)
(*(* Print the intermediate value for a computation *)*)
(*printIntermediate[tStamp_Real,total_Integer,m_Integer,n_Integer,w_Integer,tightQ:(_?BooleanQ),mode_Integer]:=Module[{outString,tStampNext},*)
(*If[mode>1,*)
(*outString=If[tightQ,"c(","C("]<>ToString[m]<>","<>ToString[n]<>","<>ToString[w]<>") = "<>ToString[total];*)
(*If[mode>2,*)
(*tStampNext=AbsoluteTime[];*)
(*Print["\[CapitalDelta]t = ",tStampNext-tStamp,", ",outString];*)
(*tStampNext,*)
(*Print[outString];*)
(*0.0]*)
(*]*)
(*]*)
(**)
(*(* Returns a lists of states that can follow from state = {row,clusts} or state = (row,clusts,ttQ} *)*)
(*nextStates[state_List,w_Integer]:=Module[{row=state[[1]],clusts=state[[2]],clusLabRow,uclusts,newRows,newLabels,newClusts,newTightQs},*)
(*clusLabRow=expandClusters[row,clusts];*)
(*uclusts=Union[clusts];*)
(*newRows=nextRows[row,w];*)
(*newLabels=Transpose[labelNext[clusLabRow,uclusts,#]&/@newRows];*)
(*newRows=Pick[newRows,newLabels[[1]]];*)
(*newClusts=Pick[newLabels[[2]],newLabels[[1]]];*)
(*If[Length[state]<3,*)
(*Transpose[{newRows,newClusts}],*)
(*newTightQs=If[state[[3]],Table[True,{Length[newRows]}],#[[1]]>0||#[[-1]]>0&/@newRows];*)
(*Transpose[{newRows,newClusts,newTightQs}]*)
(*]*)
(*]*)
(**)
(*(* Returns the canonical version of state (in order to combine equivalent state specifications) *)*)
(*canon[{row_List,clusts_List,ttQ___}]:=Module[{rrow=Reverse[row],cc,rcc},*)
(*If[row==rrow,*)
(*cc=canonClusts[clusts];*)
(*rcc=canonClusts[Reverse[clusts]];*)
(*{row,If[OrderedQ[{cc,rcc}],cc,rcc],ttQ},*)
(*If[OrderedQ[{row,rrow}],{row,canonClusts[clusts],ttQ},{rrow,canonClusts[Reverse[clusts]],ttQ}]*)
(*]*)
(*]*)
(**)
(*(* Returns the canonical version of clusts (in order to collect equivalent cluster specifications) *)*)
(*canonClusts[clusts_List]:=With[{ddc=DeleteDuplicates[clusts]},clusts/.MapThread[#1->#2&,{ddc,Range@Length@ddc}]]*)
(**)
(*(* Sums over the symmetric, connected states in a *)*)
(*symConRowTotal[a_Association]:=Total[a/@Select[Keys[a],rowSymQ[#[[1]]]&&rowConQ[#[[1]]]&]]*)
(**)
(*(* Returns count for even m *)*)
(*finishEven[a_Association,w_Integer,tightQ:(_?BooleanQ)]:=Module[{good},*)
(*good=If[tightQ,*)
(*Select[Keys[a],(#[[3]]&&goodEvenRowQ[#[[1]],w] &&goodEvenClustersQ[#])&],*)
(*Select[Keys[a],(goodEvenRowQ[#[[1]],w] &&goodEvenClustersQ[#])&]];*)
(*Total[a/@good]*)
(*]*)
(**)
(*(* Whether a final row in an even-height grid satisfies the word length \[GreaterEqual] w criterion vertically *)*)
(*goodEvenRowQ[row_List,w_Integer]:=With[{hn=Ceiling[Length[row]/2]},*)
(*NoneTrue[row[[1;;hn]]+Reverse[row[[-hn;;-1]]],0<#<w&]*)
(*]*)
(*goodEvenRowQ[_,1]:=True*)
(**)
(*(* Whether a final state in an even-height grid satisfies the single-component criterion *)*)
(*goodEvenClustersQ[{row_List,clusts_List,___}]:=Module[{labOut=labelNext[expandClusters[row,clusts],Union[clusts],Reverse[row]]},*)
(*labOut[[1]]&&(AllTrue[labOut[[2]],#<=1&]||connectedRevClustsQ[clusts,labOut[[2]]])*)
(*]*)
(**)
(*(* Returns count for odd m *)*)
(*finishOdd[a_Association,w_Integer,tightQ:(_?BooleanQ)]:=Sum[a[key]oddKeyTotal[key,w,tightQ],{key,Keys[a]}]*)
(**)
(*(* The total number of symmetric middle rows that form valid completions for a state *)*)
(*oddKeyTotal[{row_List,clusts_List,ttQ___},w_Integer,tightQ:(_?BooleanQ)]:=Module[{rrow=Reverse[row],clusLabRow,uclusts,srows,cols,labIn,labOut},*)
(*If[w>2&&AnyTrue[row+rrow,0<#<w-1&],0,*)
(*clusLabRow=expandClusters[row,clusts];*)
(*uclusts=Union[clusts];*)
(*srows=middleRows[Length[row],w,Not[tightQ]||ttQ];*)
(*Sum[*)
(*If[w>1&&Not[AllTrue[Transpose@{row,srow,rrow},goodColQ[#,w]&]],0,*)
(*labIn=labelNext[clusLabRow,uclusts,srow];*)
(*If[labIn[[1]]&&( *)
(*AllTrue[labIn[[2]],#<=1&]||( *)
(*labOut=labelNext[expandClusters[srow,labIn[[2]]],Union[labIn[[2]]],rrow];*)
(*labOut[[1]]&&( *)
(*AllTrue[labOut[[2]],#<=1&]||*)
(*connectedRevClustsQ[clusts,labOut[[2]]]*)
(*)*)
(*)*)
(*)*)
(*,1,0]*)
(*]*)
(*,{srow,srows}]*)
(*]*)
(*]*)
(**)
(*(* Whether three consecutive elements in a column satisfy the criterion that vertical word length \[GreaterEqual] w.  Here b = 0 or 1 *)*)
(*goodColQ[{a_Integer,b_Integer,c_Integer},w_Integer]:=If[b==1,a+c+1>=w,(a==0||a>=w)&&(c==0||c>=w)]*)
(**)
(*(* Whether the graph formed by connecting the clusters of one row with the reversed clusters of another is connected *)*)
(*connectedRevClustsQ[clusts_List,newClusts_List]:=Module[{rclusts=Reverse@clusts,edges1,edges2},*)
(*edges1=Flatten[Table[Partition[Flatten@Position[newClusts,j],2,1],{j,Max[newClusts]}],1];*)
(*edges2=Flatten[Table[Partition[Flatten@Position[rclusts,j],2,1],{j,Max[rclusts]}],1];*)
(*ConnectedGraphQ@Graph[Range[Length[newClusts]],#[[1]]\[UndirectedEdge]#[[2]]&/@Union[Join[edges1,edges2]]]*)
(*]*)
(**)
(*(*** Enumeration routines ***)*)
(**)
(*(* A grid is an m x n array of 0s (black squares) and 1s (white) *)*)
(*(* A symmetric grid is unchanged under 180 degree rotation *)*)
(*(* A wordy grid has all words (horizontal or vertical runs of 1s) of length \[GreaterEqual] w *)*)
(*(* A connected grid has all 1s connected in a single cluster *)*)
(*(* A tight grid has 1s touching every wall *)*)
(*(* A valid grid is symmetric, wordy, and connected, and, by default, tight *)*)
(*(* A maximal grid is a (tight) valid grid which not contained in any other valid grid *)*)
(*(* Grid G contains grid H if it contains all H's white squares and if every pair of white squares in different row words in H are in different row words in G (and similarly for column words) *)*)
(*(* During internal computation grids can be (vertically) numbered;*)
(*Here numbers range from 0 to w indicating length of current vertical run;*)
(*0 denotes a black square and w denotes a run w or more white squares *)*)
(**)
(*(** Symmetry routines **)*)
(**)
(*(* Returns lists of all canonical representatives from each of 5 symmetry classes *)*)
(*symClasses[grids_List]:=Module[{glists,slist,pos},*)
(*glists=GatherBy[Select[grids,symReducedGridQ],symType];*)
(*slist=symType@First@#&/@glists;*)
(*Table[pos=Position[slist,i];If[Length@pos==0,{},glists[[pos[[1,1]]]]],{i,5}]*)
(*]*)
(**)
(*(* All images of a grid under D4 symmetries assuming it has 180 rotational symmetry *)*)
(*allGridSymImages[grid_List]:={grid,Reverse@grid,Transpose@grid,Reverse@Transpose@grid}*)
(**)
(*(* Returns the canonical representative of a grid's coset under D4 symmetry *)*)
(*symReduceGrid[grid_List]:=With[{list=allGridSymImages[grid]},list[[Ordering[list,1][[1]]]]];*)
(**)
(*(* Whether a grid is in canonical form *)*)
(*symReducedGridQ[grid_List]:=(grid==symReduceGrid[grid]);*)
(**)
(*(* Symmetry type of a grid:  1, 2, 3, 4, or 5.  See symmetryDescriptions *)*)
(*symType[grid_List]:=If[Reverse[grid]==grid,If[Transpose[grid]==grid,1,4],If[Transpose[grid]==grid,3,If[Transpose[grid]==Reverse[grid],2,5]]];*)
(**)
(*(* Color associated with a grid via its symmetry class *)*)
(*gridColor[grid_List]:=symmetryColors[[symType@grid]];*)
(**)
(*(* Colors associated with each symmetry class (for display) *)*)
(*symmetryColors={Hue[0.05],Blue,Darker@Green,Hue[0.8],Black};*)
(**)
(*(* Text descriptions of each symmetry class *)*)
(*symmetryDescriptions={"All","Rotational","Diagonal","Horz/Vert","None"};*)
(**)
(*(* How many grids are represented by members of each symmetry class *)*)
(*symmetryOrders={1,2,2,2,4};*)
(**)
(*(** Maximality routines **)*)
(**)
(*(* Select the maximal elements of grids *)*)
(*cullToMax[grids_List]:=Module[{gl=SortBy[grids,-totWhite@#&],reaped,grid},*)
(*reaped=Reap[While[Length[gl]>0,*)
(*Sow[grid=gl[[1]]];*)
(*gl=Select[Rest[gl],Not[subGridQ[grid,#]]&];*)
(*]][[2]];*)
(*If[Length[reaped]==0,{},Reverse[reaped[[1]]]]*)
(*]*)
(**)
(*(* Checks whether grid1 contains grid2 *)*)
(*subGridQ[grid1_List,grid2_List]:=Not@MemberQ[Flatten[grid2-grid1],1]&&AllTrue[Transpose[{grid1,grid2},{3,1,2}],subRowQ]&&AllTrue[Transpose[{grid1,grid2},{3,2,1}],subRowQ]*)
(**)
(*(* Checks that any run of zeros in row2 (not next to a wall) has at least one zero among the corresponding entries in row1 (to separate the words on either side), where pairs = Transpose[{row1,row2}] *)*)
(*subRowQ[pairs_List]:=With[{splits=SplitBy[pairs,Last]},*)
(*(Length[splits]<3||AllTrue[splits[[2;;-2]],#[[1,2]]==1||AnyTrue[#,#[[1]]==0&]&])]*)
(**)
(*(*** Grid routines ***)*)
(**)
(*(** Grid generation routines **)*)
(**)
(*(* Generate all m x n grids *)*)
(*allGrids[m_Integer,n_Integer]:=Partition[#,n]&/@allRows[m n]*)
(**)
(*(* Generate all symmetric m x n grids *)*)
(*allSymGrids[m_Integer,n_Integer]:=With[{top=allGrids[Floor[m/2],n]},*)
(*If[EvenQ[m],Join[#,rotateGrid[#]]&/@top,*)
(*Flatten[Outer[Join[#1,{#2},rotateGrid[#1]]&,top,allSymRows[n],1],1]*)
(*]*)
(*]*)
(**)
(*(* Generate all m x n grids with words of length at least w *)*)
(*allWrdGrids[m_Integer,n_Integer,w_Integer]:=Module[{grids},*)
(*(* Get all grids without checking for incomplete words at the bottom *)*)
(*grids=allWrdGridsRagged[m,n,w];*)
(*(* Filter out grids with incomplete words *)*)
(*grids=Select[grids,lastRowValidQ[#[[-1]],w]&];*)
(*(* Change vertical numbers to 0/1 format *)*)
(*Map[Min[1,#]&,grids,{3}]*)
(*]*)
(*allWrdGrids[m_Integer,n_Integer,1]:=allGrids[m,n]*)
(**)
(*(* Generate all symmetric m x n grids with words of length at least w *)*)
(*allSymWrdGrids[m_Integer,n_Integer,w_Integer]:=*)
(*Module[{top,cands,mid},*)
(*If[m==1,If[w==1,allSymGrids[1,n],{{Table[0,{n}]}}],*)
(*top=Map[Min[1,#]&,allWrdGridsRagged[Floor[m/2],n,w],{3}];*)
(*cands=If[EvenQ[m],Join[#,rotateGrid[#]]&/@top,*)
(*mid=allSymWrdRows[n,w];*)
(*Flatten[Outer[Join[#1,{#2},rotateGrid[#1]]&,top,mid,1],1]*)
(*];*)
(*Select[cands,gridWrdVerQ[#,w]&]*)
(*]*)
(*]*)
(*allSymWrdGrids[m_Integer,n_Integer,1]:=allSymGrids[m,n]*)
(**)
(*(** Grid generation utilities **)*)
(**)
(*(* Rotates grid 180 degrees *)*)
(*rotateGrid[grid_List]:=Reverse[Reverse/@grid]*)
(**)
(*(* Number of 1s (white squares) in grid *)*)
(*totWhite[grid_List]:=Total[Total/@grid]*)
(**)
(*(* All partial numbered wordy grids *)*)
(*allWrdGridsRagged[m_Integer,n_Integer,w_Integer]:=Nest[extendWrdGrids[#,w]&,Transpose@{allWrdRows[n,w]},m-1]*)
(**)
(*(* Extend list of partial wordy grids to a list in which all grids have one more row *) *)
(*extendWrdGrids[grids_List,w_Integer]:=Flatten[extWrdGrid[#,w]&/@grids,1]*)
(**)
(*(* Extend a partial word grid by a single row in every possible way *)*)
(*extWrdGrid[grid_List,w_Integer]:=Append[grid,#]&/@allWrdNextRows[grid[[-1]],w]*)
(**)
(*(* Whether a row is a valid final row (no partial words) *)*)
(*lastRowValidQ[row_List,w_Integer]:=NoneTrue[row,0<#<w&]*)
(**)
(*(* Finds all rows allowed below the previous row (prev) for minimum word length w.*)
(*Entries are 0 to w denoting current length of vertical word (capped at w) *)*)
(*allWrdNextRows[prev_List,w_Integer]:=Module[{inits,rows},*)
(*(* When first element of prev is between 0 and w (= incomplete word), row below must start with horizontal numbering 1;*)
(*when first element of prev is 0 or w (= no word or complete word), row below may start with 0 or 1 *)*)
(*inits=If[0<prev[[1]]<w,{{1}},{{0},{1}}];*)
(*(* Extend all rows one element at a time, using element above in previous row (prev) *)*)
(*rows=Fold[extendWrdRows[#1,#2,w]&,inits,Rest[prev]];*)
(*(* Eliminate rows that ended before getting a tight-w word at the end *)*)
(*rows=Select[rows,Not[0<Last[#]<w]&];*)
(*(* Change horizontal numbering in rows to vertical numbering *)*)
(*renumberRow[prev,#,w]&/@rows*)
(*]*)
(**)
(*(* Renumber row to have vertical numbering consistent with previous row (prev);*)
(*Vertical numbering capped at w for consistency with dynamic programming convention *)*)
(*renumberRow[prev_List,row_List,w_Integer]:=MapThread[If[#2>0,Min[#1+1,w],0]&,{prev,row}]*)
(**)
(*(** Plotting routines **)*)
(**)
(*(* Plots a grid, color-coded by symmetry class *)*)
(*plotGrid[grid_List,squareSize_Integer:30]:=With[{col=Blend[{Black,gridColor[grid]},0.5]},ArrayPlot[grid,Mesh->True,MeshStyle->Blend[{Gray,col},0.3],ColorFunction->(If[#==1,White,col]&),ColorFunctionScaling->False,ImageSize->squareSize Length[grid[[1]]]]]*)
(**)
(*(* Internal subroutine for plotting an array of grids *)*)
(*plotGridsSub[grids_List,squareSize_Integer,width_Integer]:=With[{wid=chooseWidth[Length[grids],width]},*)
(*GraphicsGrid[Partition[plotGrid[#,squareSize]&/@grids,wid,wid,1,{}]]*)
(*]*)
(**)
(*(* Selects a pleasing array width *)*)
(*chooseWidth[n_Integer,width_Integer:0]:=Module[{d},*)
(*Min[n,If[width>0,width,*)
(*Do[If[(d=getMedDiv[n+i])>0,Break[]],{i,0,10}];*)
(*If[d>0,d,Floor[Sqrt[2.0 n]]]*)
(*]]*)
(*]*)
(**)
(*(* Returns a medium-size divisor of n, or 0 if none exists *)*)
(*getMedDiv[n_Integer,maxAspectRatio_:4.0]:=Module[{divs=Divisors[n],cwid},*)
(*cwid=divs[[1+Floor[Length[divs]/2]]];*)
(*If[cwid^2<=maxAspectRatio n,cwid,0]*)
(*]*)
(**)
(*(** Grid checks **)*)
(**)
(*(* Check that symmetric generation routine is consistent for all grids with up to bMax squares *)*)
(*allSymGridChecksQ[bMax_Integer,verboseQ_:False]:=AllTrue[allParameterPairs[bMax,verboseQ],symGridCheckQ@@#&]/;bMax>=1*)
(**)
(*(* Check that wordy generation routine is consistent for all grids with up to bMax squares *)*)
(*allWrdGridChecksQ[bMax_Integer,wMin_Integer:1,verboseQ_:False]:=AllTrue[allParameterTriples[bMax,wMin,verboseQ],wrdGridCheckQ@@#&]/;(bMax>=1&&wMin>=1)*)
(**)
(*(* Check that symmetric wordy generation routine is consistent for all grids with up to bMax squares *)*)
(*allSymWrdGridChecksQ[bMax_Integer,wMin_Integer:1,verboseQ_:False]:=AllTrue[allParameterTriples[bMax,wMin,verboseQ],symWrdGridCheckQ@@#&]/;(bMax>=1&&wMin>=1)*)
(**)
(*(* Check that symmetric generation routine is consistent for all grids with up to bMax squares *)*)
(*(* All pairs of positive integers {m,n} with m*n \[LessEqual] bMax (plus verboseQ) *)*)
(*allParameterPairs[bMax_Integer,verboseQ_:False]:=Flatten[Table[{#,b/#,verboseQ}&/@Divisors[b],{b,bMax}],1]/; bMax>=1*)
(**)
(*(* All triples of positive integers {m,n,w} with m \[GreaterEqual] w, n \[GreaterEqual] w, and m*n \[LessEqual] bMax (plus verboseQ) *)*)
(*allParameterTriples[bMax_Integer,wMin_Integer:1,verboseQ_:False]:=Flatten[Table[Select[{#,b/#,w,verboseQ}&/@Divisors[b],#[[1]]>=w&&#[[2]]>=w&],{b,bMax},{w,wMin,Floor@Sqrt@bMax}],2]/;(bMax>=1&&wMin>=1)*)
(**)
(*(* Check that allSymGrids gives the symmetric rows from allGrids *)*)
(*symGridCheckQ[m_Integer,n_Integer,verboseQ_:False]:=With[{ckQ=(allSymGrids[m,n]==Select[allGrids[m,n],gridSymQ])},*)
(*If[verboseQ,Print["allSymGrids[",m,",",n,"] equals the symmetric grids in allGrids[",m,",",n,"]? ",ckQ]];*)
(*ckQ]/;(m>=1&&n>=1)*)
(**)
(*(* Check that allWrdGrids gives the wordy grids from allGrids *)*)
(*wrdGridCheckQ[m_Integer,n_Integer,w_Integer,verboseQ_:False]:=With[{ckQ=If[m<w||n<w,allWrdGrids[m,n,w]=={Table[0,{m},{n}]},*)
(*(allWrdGrids[m,n,w]==Select[allGrids[m,n],gridWrdQ[#,w]&])]},*)
(*If[verboseQ,Print["allWrdGrids[",m,",",n,",",w,"] equals the grids in allGrids[",m,",",n,"] with words of length \[GreaterEqual] ",w,"? ",ckQ]];*)
(*ckQ]/;(m>=1&&n>=1&&w>=1)*)
(**)
(*(* Check that allSymWrdGrids gives the symmetric rows from allWrdGrids and the wordy rows from allSymGrids *)*)
(*symWrdGridCheckQ[m_Integer,n_Integer,w_Integer,verboseQ_:False]:=Module[{aswGrids=allSymWrdGrids[m,n,w],ck1Q,ck2Q},*)
(*If[m<w||n<w,ck1Q=ck2Q=(aswGrids=={Table[0,{m},{n}]}),*)
(*ck1Q=(aswGrids==Select[allWrdGrids[m,n,w],gridSymQ]);*)
(*ck2Q=(aswGrids==Select[allSymGrids[m,n],gridWrdQ[#,w]&])*)
(*];*)
(*If[verboseQ,Print["allSymWrdGrids[",m,",",n,",",w,"] equals the symmetric grids in allWrdGrids[",m,",",n,",",w,"]? ",ck1Q]];*)
(*If[verboseQ,Print["allSymWrdGrids[",m,",",n,",",w,"] equals the grids in allSymGrids[",m,",",n,"] with words of length \[GreaterEqual] ",w,"? ",ck2Q]];*)
(*ck1Q&&ck2Q]/;(m>=1&&n>=1&&w>=1)*)
(**)
(*(** Grid properties **)*)
(**)
(*(* Is grid symmetric?  (is the grid unchanged under a 180 degree rotation?) *)*)
(*gridSymQ[grid_List]:=(rotateGrid[grid]==grid)*)
(**)
(*(* Is grid connected?  (is graph formed by connecting adjacent white squares connected?) *)*)
(*gridConQ[grid_List]:=ConnectedGraphQ[Graph[Position[grid,1],Join[#\[UndirectedEdge](#+{1,0})&/@Position[Total/@Partition[grid,2,1],2],*)
(*Reverse[#]\[UndirectedEdge]Reverse[#+{1,0}]&/@Position[Total/@Partition[Transpose@grid,2,1],2]*)
(*]]]*)
(**)
(*(* Is grid tight?  (is there a 1 on all four edges?) *)*)
(*gridTgtQ[grid_List]:=Total[grid[[1]]]>0&&Total[grid[[-1]]]>0&&Total[grid[[All,1]]]>0&&Total[grid[[All,-1]]]>0*)
(**)
(*(* Is grid wordy?  (do all its words have length at least w? *)*)
(*gridWrdQ[grid_List,w_Integer]:=gridWrdHorQ[grid,w]&&gridWrdVerQ[grid,w]*)
(*gridWrdQ[_List,1]:=True*)
(**)
(*(* Is grid horizonally wordy?  (are all its rows wordy?) *)*)
(*gridWrdHorQ[grid_List,w_Integer]:=AllTrue[grid,rowWrdQ[#,w]&]*)
(**)
(*(* Is grid vertically wordy?  (are all its columns wordy?) *)*)
(*gridWrdVerQ[grid_List,w_Integer]:=gridWrdHorQ[Transpose@grid,w]*)
(**)
(*(*** Row routines ***)*)
(**)
(*(* A row is length-n array of 0s (black squares) and 1s (white) *)*)
(*(* A symmetric row is unchanged when reversed *)*)
(*(* A wordy row has all words (runs of 1s) of length \[GreaterEqual] w *)*)
(*(* A connected row has 0 or 1 words *)*)
(*(* A tight row has 1s as its first and last entries *)*)
(*(* During internal computation rows can be horizontally numbered;*)
(*Here 0 denotes a black square;*)
(*Positive numbers denote length of current horizontal run of white squares *)*)
(**)
(*(** Row generation routines **)*)
(**)
(*(* Generate rows of length n *)*)
(*allRows[n_Integer]:=Tuples[{0,1},n]*)
(**)
(*(* Generate all symmetric rows of length n *)*)
(*allSymRows[n_Integer]:=With[{first=allRows[Floor[n/2]]},*)
(*If[EvenQ[n],Join[#,Reverse[#]]&/@first,*)
(*Flatten[Outer[Join[#1,{#2},Reverse[#1]]&,first,{0,1},1],1]*)
(*]*)
(*]*)
(**)
(*(* Generate all rows of length n with all words of length at least w *)*)
(*allWrdRows[n_Integer,w_Integer]:=Map[Min[#,1]&,Select[allWrdRowsRagged[n,w],Not[0<Last[#]<w]&],{2}]*)
(*allWrdRows[n_Integer,1]:=allRows[n]*)
(**)
(*(* Generate all symmetric rows of length n with all words of length at least w *)*)
(*allSymWrdRows[n_Integer,w_Integer]:=Module[{hw=If[OddQ[w],(w+1)/2,w/2+Mod[n,2]],rows},*)
(*rows=Map[Min[#,1]&,Select[allWrdRowsRagged[Ceiling[n/2],w],Not[0<Last[#]<hw]&],{2}];*)
(*Join[#,Reverse@Drop[#,-Mod[n,2]]]&/@rows*)
(*]*)
(*allSymWrdRows[n_Integer,1]:=allSymRows[n]*)
(**)
(*(** Row generation utilities **)*)
(**)
(*(* Generate all horizontally numbered partial wordy rows (no check on final word length) *)*)
(*allWrdRowsRagged[n_Integer,w_Integer]:=Nest[extendWrdRows[#1,0,w]&,{{0},{1}},n-1]*)
(**)
(*(* Extend list of partial rows by one column where j is column entry in the row above.*)
(*Here entries > 1 denote the horizontal word length (and are not capped at w).*)
(*These will be renumbered to denote vertical word lengths when appended to the grid *)*)
(*extendWrdRows[rows_List,j_Integer,w_Integer]:=With[{zerAllowedQ=(j==0||j>=w)},*)
(*Flatten[With[{k=Last[#]},If[zerAllowedQ&&(k==0||k>=w),{Append[#,0],Append[#,k+1]},{Append[#,k+1]}]]&/@rows,1]]*)
(**)
(*(** Row checks **)*)
(**)
(*(* Check that row generation routines are consistent for all n and w *)*)
(*allRowChecksQ[nMax_Integer:15,wmax_Integer:7]:=And@@Flatten@Table[rowCheckQ[n,w],{n,nMax},{w,wmax}]/;(nMax>=1&&wmax>=1)*)
(**)
(*(* Check that row generation routines are consistent with one another *)*)
(*rowCheckQ[n_Integer,w_Integer]:=(symRowCheckQ[n]&&wrdRowCheckQ[n,w]&&symWrdRowCheckQ[n,w])/;(n>=1&&w>=1)*)
(**)
(*(* Check that allSymRows gives the symmetric rows from allRows *)*)
(*symRowCheckQ[n_Integer]:=(allSymRows[n]==Select[allRows[n],rowSymQ])/;n>=1*)
(**)
(*(* Check that allWrdRows gives the wordy rows from allRows *)*)
(*wrdRowCheckQ[n_Integer,w_Integer]:=(allWrdRows[n,w]==Select[allRows[n],rowWrdQ[#,w]&])/;(n>=1&&w>=1)*)
(**)
(*(* Check that allSymWrdRows gives the symmetric rows from allWrdRows and the wordy rows from allSymRows *)*)
(*symWrdRowCheckQ[n_Integer,w_Integer]:=With[{aswRows=allSymWrdRows[n,w]},*)
(*(aswRows==Select[allWrdRows[n,w],rowSymQ]&&aswRows==Select[allSymRows[n],rowWrdQ[#,w]&])]/;(n>=1&&w>=1)*)
(**)
(*(** Row properties **)*)
(**)
(*(* Is row symmetric?  (is it the same when reversed?) *)*)
(*rowSymQ[row_List]:=(row==Reverse[row])*)
(**)
(*(* Is row connected? (does it have at most one word?) *)*)
(*rowConQ[row_List]:=(Length@Select[Split[row],#[[1]]==1&]<=1)*)
(**)
(*(* Is row tight?  (is there a 1 on both ends?) *)*)
(*rowTgtQ[row_List]:=(row[[1]]==1&&row[[-1]]==1)*)
(**)
(*(* Is row wordy?  (do all words in row have length at least w? *)*)
(*rowWrdQ[row_List,w_Integer]:=AllTrue[Split[row],#[[1]]==0||Length[#]>=w&]*)
(*rowWrdQ[_List,1]:=True*)
(**)
(*End[];*)
(**)
(*EndPackage[];*)
